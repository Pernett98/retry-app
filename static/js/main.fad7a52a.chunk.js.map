{"version":3,"sources":["logger.ts","ports/http/client/circuitBreakerHttpClient.ts","ports/http/services/repositoryService.ts","ports/dom/Configure/useForm.ts","ports/dom/Configure/Configure.tsx","ports/dom/RepositoryList/useRepositoryData.ts","ports/dom/RepositoryList/RepositoryList.tsx","ports/dom/App.tsx","mock_server/generateData.ts","mock_server/handlers.ts","mock_server/browser.ts","index.ts","ports/dom/index.tsx"],"names":["getLoggerEntry","prefix","entry","C","infoCircuitBraker","infoExponentialBackoff","shouldRetry","ref","check","flow","result","isClosed","isBreakerStateClosed","breakerState","read","tag","breakerEnvironment","pipe","IO","state","a","E","handleErrors","response","ok","Promise","reject","Error","status","toString","client","breakerConfig","IOR","breakerClosed","retryConfig","maxTime","delay","limit","maxBreakerFailures","request","circuitBreaker","fetcher","retryPolicy","capDelay","monoidRetryPolicy","concat","exponentialBackoff","limitRetries","configureRetryPolicy","retrying","TE","previousDelay","O","logDelay","breakerService","circuitBreakerHttpClient","resetTimeoutSecs","breakerDescription","fetchRepositories","fetch","then","res","json","useForm","handleOnFinish","useCallback","formData","failures","configureFailure","layout","labelCol","span","wrapperCol","tailLayout","offset","Configure","orientation","initialValues","size","onFinish","Item","name","label","min","max","type","htmlType","useRepositoryData","useState","initial","repositories","setRepositories","getRepos","pending","err","T","failure","success","getRepositories","columns","title","dataIndex","key","foldRepoData","fold","active","error","message","dataSource","map","r","i","RepositoryList","onClick","App","genRepositories","recordOf","string","starts","int","language","sampleGenerator","generateSample","count","seed","mkSeed","handlers","rest","get","req","ctx","Number","url","searchParams","failureCounter","setupWorker","start","catch","console","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fad7a52a.chunk.js","sourcesContent":["import * as C from 'fp-ts/lib/Console'\nimport * as L from 'logging-ts/lib/IO'\n\nfunction showEntry(message: string): string {\n  return `${message}`\n}\n\nfunction getLoggerEntry(prefix: string): L.LoggerIO<string> {\n  return entry => C.log(`${prefix}: ${showEntry(entry)}`)\n}\n\nexport const infoCircuitBraker = getLoggerEntry('circuitBreaker')\n\nexport const infoExponentialBackoff = getLoggerEntry('exponentialBackoff')","import { Either } from 'fp-ts/lib/Either';\nimport { TaskEither } from 'fp-ts/lib/TaskEither';\nimport { Task } from 'fp-ts/lib/Task';\nimport { State } from 'fp-ts/lib/State';\nimport * as O from 'fp-ts/lib/Option'\nimport * as TE from 'fp-ts/lib/TaskEither';\nimport * as IOR from 'fp-ts/lib/IORef';\nimport * as IO from 'fp-ts/lib/IO';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nimport { breakerClosed } from 'circuit-breaker-monad/lib/helpers';\nimport { circuitBreaker } from 'circuit-breaker-monad/lib';\nimport { BreakerEnvironment, BreakerOptions } from 'circuit-breaker-monad/lib/types';\nimport {\n  capDelay,\n  exponentialBackoff,\n  limitRetries,\n  monoidRetryPolicy,\n  RetryStatus,\n} from 'retry-ts'\nimport { retrying } from 'retry-ts/lib/Task'\nimport { infoExponentialBackoff, infoCircuitBraker } from '../../../logger';\n\nexport type RetryConfig = {\n  maxTime: number,\n  delay: number,\n  limit: number,\n};\n\nexport type BreakerConfig = BreakerOptions & {\n  maxTime: number,\n  delay: number\n};\n\nconst configureRetryPolicy = ({ maxTime, delay, limit }: RetryConfig) => capDelay(\n  maxTime,\n  monoidRetryPolicy\n    .concat(\n      exponentialBackoff(delay),\n      limitRetries(limit)\n    )\n)\n\ntype ShouldRetry<E,A> = {\n  ref: BreakerEnvironment<A>,\n  check: (result: Either<Error | E, A>) => boolean\n}\n\nconst shouldRetry = <E, A>({\n  ref,\n  check\n}: ShouldRetry<E, A>) => flow(\n  (result: Either<E, A>) => ({\n    result,\n    isClosed: isBreakerStateClosed(ref)()\n  }),\n  ({isClosed, result}) => isClosed && check(result),\n  result => {\n    infoCircuitBraker(`state is: ${ref.breakerState.read().tag}`)()\n    infoExponentialBackoff(`should retry? ${result}`)()\n    return result\n  }\n)\n\nconst isBreakerStateClosed = <A>(breakerEnvironment: BreakerEnvironment<A>) =>\n  pipe(\n    breakerEnvironment.breakerState.read,\n    IO.map(state => state.tag === 'Closed')\n  )\n\nconst logDelay = (status: RetryStatus) =>\n  TE.rightIO(\n    infoExponentialBackoff(\n      pipe(\n        status.previousDelay,\n        O.map(delay => `retrying in ${delay} milliseconds...`),\n        O.getOrElse(() => 'first attempt...')\n      )\n    )\n  )\n\nexport const circuitBreakerHttpClient = (\n  breakerConfig: BreakerConfig,\n) => {\n  const breakerState = IOR.newIORef(breakerClosed(0))();\n  const retryConfig = {\n    maxTime: breakerConfig.maxTime,\n    delay: breakerConfig.delay,\n    limit: breakerConfig.maxBreakerFailures,\n  };\n\n  return <\n    E extends Error,\n    A,\n    T extends Task<A> = Task<A>\n  >(\n    request: T,\n    check: (a: Either<Error | E, A>) => boolean,\n  ) =>  {\n    const breakerService: State<BreakerEnvironment<A>, TaskEither<Error | E, A>> = (\n      { request, breakerState }\n    ) => {\n\n      const fetcher = circuitBreaker<A>()(breakerConfig);\n      const [result, ref] = fetcher({ request, breakerState })\n\n      const retryPolicy = configureRetryPolicy(retryConfig);\n\n      return [\n        retrying(\n          retryPolicy,\n          (status) => pipe(\n            logDelay(status),\n            TE.apSecond(result)\n          ),\n          shouldRetry<E | Error,A>({\n            check,\n            ref\n          })\n        ),\n        ref,\n      ];\n    };\n\n    return breakerService({ breakerState, request });\n  };\n}\n","import { failure, RemoteData, success } from '@devexperts/remote-data-ts'\nimport * as E from 'fp-ts/lib/Either'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport * as T from 'fp-ts/lib/Task'\nimport { pipe } from 'fp-ts/lib/function'\nimport { Repository } from \"../../../domain/Repository\";\nimport { BreakerConfig, circuitBreakerHttpClient } from \"../client/circuitBreakerHttpClient\"\n\nconst check = (a: E.Either<Error, Repository[]>) => E.isLeft(a);\nconst breakerOptions: BreakerConfig = {\n  maxTime: 20000,\n  delay: 400,\n  maxBreakerFailures: 3,\n  resetTimeoutSecs: 10,\n  breakerDescription: 'The service is Unavailable'\n}\n\nconst handleErrors = (response: Response) => !response.ok ? \n  Promise.reject(new Error(\n    `server failed with status: ${response.status.toString()}`\n  )) : \n  response\n\n  \nconst client = circuitBreakerHttpClient(breakerOptions)\n\nexport const configureFailure = (failures: number) => \n  fetch(`config?failures=${failures}`)\n\nconst fetchRepositories = () => fetch('repositories')\n  .then(handleErrors)\n  .then(res => res.json())\n\nexport const getRepositories = () => pipe(\n  client(\n    fetchRepositories,\n    check\n  ),\n  ([req]) => req,\n  TE.fold<Error, Repository[], RemoteData<Error, Repository[]>>(\n      err => T.of(failure(err)), \n      repositories => T.of(success(repositories))\n    )\n)\n\n","import { useCallback } from \"react\"\nimport { configureFailure } from \"../../http/services/repositoryService\"\n\nexport const useForm = () => {\n  \n   const handleOnFinish = useCallback(\n    (formData) => configureFailure(formData.failures),\n    [],\n  )\n\n  return {\n    handleOnFinish,\n  }\n}","import { Divider, InputNumber, Button, Form } from 'antd'\nimport React from 'react'\nimport { useForm } from './useForm'\n\nconst layout = {\n  labelCol: {\n    span: 8,\n  },\n  wrapperCol: {\n    span: 16,\n  },\n};\nconst tailLayout = {\n  wrapperCol: {\n    offset: 8,\n    span: 16,\n  },\n};\n\nexport const Configure = () => {\n  const {\n    handleOnFinish\n  } = useForm()\n\n  return (\n    <div>\n      <Divider orientation='center'>\n        Configure Failures\n      </Divider>\n      <Form \n        {...layout}\n        initialValues={{\n          failures: 3\n        }}\n        size='large'\n        onFinish={handleOnFinish}\n      >\n        <Form.Item\n          name='failures'\n          label='Failures'\n        >\n          <InputNumber\n            min={0}\n            max={10}\n          />\n        </Form.Item>\n        <Form.Item {...tailLayout}>\n          <Button type='primary' htmlType=\"submit\">\n            Config\n          </Button>\n        </Form.Item>\n      </Form>\n    </div>\n  )\n}","import { useCallback, useState } from \"react\"\nimport { initial, pending, RemoteData } from '@devexperts/remote-data-ts'\n\nimport { Repository } from \"../../../domain/Repository\"\n\nimport { getRepositories } from '../../http/services/repositoryService'\n\nexport const useRepositoryData = () => {\n  const [repositories, setRepositories] = useState<RemoteData<Error, Repository[]>>(initial)\n  const getRepos = useCallback(\n  () => {\n    setRepositories(pending)\n    getRepositories()()\n      .then(setRepositories)\n  },\n    [],\n  )\n\n  return {\n    repositories,\n    getRepos\n  }\n}","import React from 'react'\nimport { useRepositoryData } from './useRepositoryData'\nimport { fold } from '@devexperts/remote-data-ts'\n\nimport { Repository } from '../../../domain/Repository'\nimport { Table, Skeleton, Alert, Button, Divider } from 'antd'\n\nconst columns = [\n  {\n    title: 'Name',\n    dataIndex: 'name',\n    key: 'name',\n  },\n  {\n    title: 'Language',\n    dataIndex: 'language',\n    key: 'language',\n  },\n  {\n    title: 'Starts',\n    dataIndex: 'starts',\n    key: 'starts',\n  },\n];\n\nconst renderRepositories = (repositories: Repository[]) => (\n  <Table\n    dataSource={repositories.map((r, i)=> ({...r, key: i}))} \n    columns={columns}\n  />\n)\n\nconst renderLoading = () => <Skeleton active />\n\n\nconst renderInitial = () => <></>\n\nconst renderError = (error: Error) => (\n  <Alert \n    type='error'\n    message={error.message}\n  />\n)  \n\nconst foldRepoData = fold<Error, Repository[], JSX.Element>(\n  renderInitial,\n  renderLoading,\n  renderError,\n  renderRepositories,\n)\n\nexport const RepositoryList = () => {\n  const {\n    repositories,\n    getRepos\n  } = useRepositoryData()\n  \n  return (\n    <div>\n      <Divider>Repositories</Divider>\n      <Button \n        size='large' \n        type='primary'\n        onClick={getRepos}\n      >\n        Search\n      </Button>\n      {foldRepoData(repositories)}\n    </div>\n  )\n}","import React from 'react';\nimport './App.css';\nimport { Configure } from './Configure/Configure';\nimport { RepositoryList } from './RepositoryList/RepositoryList';\n\nfunction App() {\n  return (\n    <>\n      <Configure />\n      <RepositoryList />\n    </>\n  );\n}\n\nexport default App;\n","import { Repository } from '../domain/Repository'\nimport { \n  Gen, \n  generateSample, \n  recordOf,\n  string,\n  int,\n  mkSeed,\n} from '@no-day/fp-ts-generators'\n\nconst genRepositories: Gen<Repository> = recordOf({\n  name: string(),\n  starts: int({ min: 0, max: 100 }),\n  language: string()\n})\n\nconst sampleGenerator = generateSample({\n  count: 30,\n  seed: mkSeed(1998),\n  size: 25\n})\n\nexport const generateRepositories = () => sampleGenerator(genRepositories)","import { rest } from 'msw'\nimport { generateRepositories } from './generateData'\n\nlet failures = 3\n\nexport const handlers = [\n  rest.get('/config', (req, res, ctx) => {\n    failures = Number(req.url.searchParams.get('failures')) || 3\n    return res(\n      ctx.status(200),\n      ctx.json({\n        message: 'configured'\n      })\n    )\n  }),\n  rest.get('/repositories', (req, res, ctx) => {\n    const result = failures > 0 ?\n    res(\n      ctx.status(500),\n      ctx.json({ failureCounter: failures })\n    ) :\n    res(\n      ctx.status(200),\n      ctx.json(generateRepositories())\n    )\n    failures >= 0 && failures--\n    return result\n  }),\n]\n","import { setupWorker } from 'msw'\nimport { handlers } from './handlers'\n// This configures a Service Worker with the given request handlers.\nexport const worker = setupWorker(...handlers)\n\n","import { createReactApp } from './ports/dom'\nimport { worker } from './mock_server/browser'\n\nworker.start()\n  .catch(err => console.error(err))\n\ncreateReactApp()\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'antd/dist/antd.css';\nimport './index.css';\nimport App from './App';\n\nexport const createReactApp = () => {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n  );\n\n}\n"],"sourceRoot":""}